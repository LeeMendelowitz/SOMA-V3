#! /usr/bin/env python

import os
import sys
import argparse
from collections import defaultdict

############################################
argParser = argparse.ArgumentParser(description='Convert rebase.staden into a python module')
argParser.add_argument('-f', '--file', 
                       help = 'Path to rebase.staden text file. Default: rebase.staden',
                       default = 'rebase.staden')
argParser.add_argument('-o', '--output',
                       help = 'Path to output python module. Default: rebase.py',
                       default = 'rebase.py')

############################################
class DuplicateEnzyme(Exception):
    pass

class FileExists(Exception):
    pass

############################################
# Pretty print a variable
# Currently only defined for dictionary
def prettyPrint(var):

    if type(var) is dict:
        outS = ['{\n']
        outS.extend('\t%s : %s,\n'%(repr(k), repr(v)) for k,v in var.iteritems())
        outS.append('}\n')
        outS = ''.join(outS)
        return outS
    else:
        return repr(var)

############################################
# Read a rebase.staden file
def readRebase(fname):
    with open(fname) as fin:
        comment = ''
        rebase = defaultdict(list)
        lines = (l.strip() for l in fin)
        selectedLines = (l for l in lines if l)
        for l in selectedLines:
            isComment = len(l) < 2 or l[-2:] != '//'
            if isComment:
                comment += '%s\n' % l
                continue
            fields = l.split('/')
            enzyme = fields[0].upper()
            recSeqs = [field.replace("'", '').upper() for field in fields[1:] if field]
            try:
                if enzyme in rebase:
                    raise DuplicateEnzyme('Duplicate Enzyme in rebase.staden: %s' % enzyme)
            except DuplicateEnzyme as e:
                sys.stdout.write('WARNING: %s\n'%str(e))
            rebase[enzyme].extend(recSeqs)

    rebase = dict(rebase)
    return (comment, rebase)



############################################
# Write a python module defining the variables passed via kwargs
# The special keyword argument '__header__' (optional) prints
# a header at the top of the python module.

def writeModule(moduleName, **kwargs):
    if os.path.exists(moduleName):
        raise FileExists('Output module already exists! %s' % moduleName)
    fout = open(moduleName, 'w')

    if '__header__' in kwargs:
        fout.write('%s'%kwargs['__header__'])

    for (name, var,) in kwargs.iteritems():
        if name == '__header__':
            continue
        fout.write('%s = %s\n\n' % (name, prettyPrint(var)))

    fout.close()



############################################
def main():
    args = argParser.parse_args()
    inputFile = args.file
    outputFile = args.output

    sys.stderr.write('InputFile: %s\n'%inputFile)
    sys.stderr.write('OutputFile: %s\n'%outputFile)

    if os.path.exists(outputFile):
        sys.stdout.write('ERROR: Output file %s already exists! Please erase or specify a new output file.\n'%outputFile)
        return

    header = '# %s\n'%outputFile  +  \
             '# Defines enzyme recognition sequences\n' + \
             '# Autogenerated by %s\n'%(__file__) + '\n'*5
    
    comment, rebase = readRebase(inputFile)

    commentLines = comment.split('\n')
    for cl in commentLines:
        header += '# %s\n'%cl
    header += '\n'*5

    writeModule(outputFile, __header__ = header, rebase = rebase)


############################################
if __name__ == '__main__':
    main()



